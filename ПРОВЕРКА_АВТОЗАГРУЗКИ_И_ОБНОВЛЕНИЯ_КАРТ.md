# Проверка реализации автоматической загрузки транзакций и обновления данных по картам

## Обзор

В системе реализованы следующие механизмы:

1. **Автоматическая загрузка транзакций** - загрузка транзакций по расписанию из Firebird и API
2. **Обновление данных по картам через регламент** - автоматическое обновление информации по картам по расписанию
3. **Обновление данных по карте через карточку карты** - ручное обновление информации по конкретной карте

## Краткая сводка реализации

✅ **Автоматическая загрузка транзакций** - реализована и работает
- Планировщик запускается при старте приложения
- Поддерживает cron-выражения и простые форматы расписания
- Работает для всех типов подключений (Firebird, API, Web)

✅ **Обновление данных по картам через регламент** - реализовано и работает
- Регламенты создаются и управляются через интерфейс
- Поддерживают фильтрацию карт (по номерам, статусу, привязке к ТС)
- Автоматически обновляют карты данными из Web API

✅ **Обновление через карточку карты** - реализовано и работает
- Кнопка "Получить информацию из API" в модальном окне редактирования карты
- Автоматически обновляет карту при получении информации
- Работает для шаблонов с типом подключения "web"

## 1. Автоматическая загрузка транзакций

### Компоненты

- **SchedulerService** (`backend/app/services/scheduler_service.py`) - управление планировщиком задач
- **AutoLoadService** (`backend/app/services/auto_load_service.py`) - сервис автоматической загрузки транзакций
- **ProviderTemplate** - шаблоны провайдеров с настройками автозагрузки

### Настройка

Для каждого шаблона провайдера можно настроить:

- `auto_load_enabled` (Boolean) - включена ли автоматическая загрузка
- `auto_load_schedule` (String) - расписание в формате cron или простом формате:
  - `"daily"` или `"day"` - каждый день в 2:00
  - `"hourly"` или `"hour"` - каждый час
  - `"weekly"` или `"week"` - каждую неделю
  - `"every N minutes/hours/days"` - каждые N минут/часов/дней
  - Cron-выражение: `"минута час день месяц день_недели"` (например, `"0 2 * * *"` - каждый день в 2:00)
- `auto_load_date_from_offset` (Integer) - смещение в днях от текущей даты для начальной даты (по умолчанию -7)
- `auto_load_date_to_offset` (Integer) - смещение в днях от текущей даты для конечной даты (по умолчанию -1)

### Как работает

1. При запуске приложения `SchedulerService` загружает все активные шаблоны с включенной автозагрузкой
2. Для каждого шаблона создается задача в планировщике APScheduler
3. По расписанию вызывается `AutoLoadService.load_template()`
4. Сервис вычисляет период загрузки на основе offset'ов
5. Загружаются транзакции через API или Firebird в зависимости от типа подключения
6. Результаты сохраняются в `upload_events` с флагом `is_scheduled=True`

### Проверка работы

#### 1. Проверка статуса планировщика

```bash
GET /api/v1/templates/scheduler/status
```

Ответ содержит:
- `scheduler_running` - запущен ли планировщик
- `scheduled_jobs` - список запланированных задач
- `recent_auto_events` - последние события автозагрузки за 7 дней

#### 2. Проверка событий в БД

```sql
SELECT 
    id,
    created_at,
    source_type,
    is_scheduled,
    status,
    file_name,
    template_id,
    transactions_created,
    transactions_total,
    message
FROM upload_events
WHERE source_type = 'auto' 
  AND is_scheduled = true
ORDER BY created_at DESC
LIMIT 20;
```

#### 3. Ручной запуск автозагрузки

```bash
POST /api/v1/templates/auto-load
```

Загружает транзакции для всех шаблонов с `auto_load_enabled = true`

### Логи

При запуске приложения:
```
Планировщик задач автоматической загрузки запущен
Загрузка расписаний автоматической загрузки
Расписания автоматической загрузки загружены
```

При выполнении задач:
```
Запуск автоматической загрузки по расписанию
Автоматическая загрузка для шаблона
Запись события автозагрузки в журнал
```

## 2. Обновление данных по картам через регламент

### Компоненты

- **CardInfoSchedule** (`backend/app/models.py`) - модель регламента
- **CardInfoScheduleService** (`backend/app/services/card_info_schedule_service.py`) - сервис выполнения регламента
- **SchedulerService** - управление расписанием регламентов

### Настройка регламента

Регламент настраивается через интерфейс или API:

- `name` - название регламента
- `description` - описание
- `provider_template_id` - ID шаблона провайдера с типом подключения "web"
- `schedule` - расписание (cron-выражение или простой формат)
- `filter_options` - фильтр карт (JSON):
  ```json
  {
    "card_numbers": ["1100018800004794", ...],  // конкретные номера карт (если пусто - все карты провайдера)
    "only_with_vehicle": true/false,  // только карты, привязанные к ТС
    "only_blocked": true/false,  // только заблокированные карты
    "only_active": true/false  // только активные карты
  }
  ```
- `auto_update` - автоматически обновлять карты данными из API
- `flags` - флаги реквизитов для запроса (битовая маска, по умолчанию 23)
- `is_active` - активен ли регламент

### Как работает

1. При запуске приложения `SchedulerService` загружает все активные регламенты
2. Для каждого регламента создается задача в планировщике
3. По расписанию вызывается `CardInfoScheduleService.execute_schedule()`
4. Сервис получает список карт по фильтру
5. Для каждой карты вызывается `adapter.get_card_info()` для получения информации из API
6. Если `auto_update = true`, карта обновляется данными из API:
   - `PersonName` → `original_owner_name` (с нормализацией в `normalized_owner`)
   - `State` → `is_blocked` (0 = работает, 1/2/4 = заблокирована)
7. Результат сохраняется в `last_run_result` регламента

### Проверка работы

#### 1. Список регламентов

```bash
GET /api/v1/card-info-schedules
```

#### 2. Ручной запуск регламента

```bash
POST /api/v1/card-info-schedules/{schedule_id}/run
```

Запускает регламент немедленно, независимо от расписания. Требует прав администратора.

#### 3. Проверка результатов

Результаты последнего выполнения хранятся в поле `last_run_result` регламента:

```json
{
  "status": "success|partial|error",
  "cards_processed": 10,
  "cards_updated": 8,
  "cards_failed": 2,
  "error_message": "..."
}
```

### Логи

При выполнении регламента:
```
Начало выполнения регламента получения информации по картам: {name}
Найдено карт для обработки: {count}
Завершено выполнение регламента: {name}
```

## 3. Обновление данных по карте через карточку карты

### Компоненты

- **CardInfoModal** (`src/components/CardInfoModal.jsx`) - модальное окно для отображения информации по карте
- **FuelCardEditModal** (`src/components/FuelCardEditModal.jsx`) - модальное окно редактирования карты
- **Endpoint** `/api/v1/fuel-cards/info` - получение информации по карте

### Как работает

1. Пользователь открывает карточку карты (FuelCardEditModal)
2. В карточке есть кнопка "Получить информацию из API" (если указан `provider_template_id`)
3. При нажатии открывается `CardInfoModal`
4. Модальное окно отправляет запрос:
   ```javascript
   POST /api/v1/fuel-cards/info
   {
     "card_number": "1100018800004794",
     "provider_template_id": 1,
     "flags": 23,
     "update_card": true  // автоматически обновить карту
   }
   ```
5. Сервер получает информацию через `adapter.get_card_info()`
6. Если `update_card = true`, карта обновляется:
   - `PersonName` → `original_owner_name` (с нормализацией)
   - `State` → `is_blocked`
7. Обновленная информация возвращается клиенту

### Проверка работы

1. Откройте список карт
2. Выберите карту и нажмите "Редактировать"
3. Если у карты указан провайдер с шаблоном типа "web", появится кнопка "Получить информацию из API"
4. Нажмите кнопку - откроется модальное окно с информацией
5. Если `update_card = true`, карта автоматически обновляется

## Общие проверки

### 1. Проверка запуска планировщика

При запуске приложения планировщик должен автоматически запуститься. Проверьте логи:

```
Планировщик задач автоматической загрузки запущен
Загрузка расписаний автоматической загрузки
Расписания автоматической загрузки загружены
Регламенты получения информации по картам загружены
```

### 2. Проверка активных задач

```bash
GET /api/v1/templates/scheduler/status
```

Проверьте:
- `scheduler_running` = `true`
- `scheduled_jobs` содержит задачи для шаблонов и регламентов

### 3. Проверка последних событий

В ответе `/api/v1/templates/scheduler/status` есть поле `recent_auto_events` с последними событиями автозагрузки.

### 4. Перезагрузка расписаний

Если изменили настройки шаблона или регламента:

```bash
POST /api/v1/templates/scheduler/reload
```

Или перезапустите приложение.

## Возможные проблемы

### Планировщик не запускается

- Проверьте, что APScheduler установлен: `pip install apscheduler`
- Проверьте логи на наличие ошибок при запуске
- Убедитесь, что планировщик инициализируется в `main.py`

### Задачи не выполняются

- Проверьте, что шаблоны/регламенты активны (`is_active = true`)
- Проверьте, что `auto_load_enabled = true` для шаблонов
- Проверьте формат расписания (cron или простой формат)
- Проверьте логи на наличие ошибок при выполнении

### Данные не обновляются

- Проверьте, что `auto_update = true` в регламенте
- Проверьте, что `update_card = true` в запросе через карточку
- Проверьте, что шаблон провайдера имеет тип подключения "web"
- Проверьте, что API возвращает данные (логи адаптера)

## Рекомендации

1. **Мониторинг**: Регулярно проверяйте статус планировщика и результаты выполнения задач
2. **Логирование**: Включите детальное логирование для отладки проблем
3. **Тестирование**: Перед настройкой расписания протестируйте загрузку вручную
4. **Резервное копирование**: Регулярно делайте резервные копии БД перед массовыми обновлениями
